/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Level;

import Entities.BatEntity;
import Entities.Entity;
import Entities.Player;
import Entities.Player2;
import Entities.SpiderEntity;
import Entities.SqueletonEntity;
import Entities.ZombieEntity;

import Graphique.Tile.ChestTile;
import Graphique.Tile.DoorTile;
import Graphique.Item.Item;
import Graphique.Tile.BatSpawnTile;
import Graphique.Tile.MetalDoor;
import Graphique.Tile.OpenedChestTile;
import Graphique.Tile.OpenedDoorTile;
import Graphique.Tile.OpenedMetalDoor;
import Graphique.Tile.SpiderSpawnTile;
import Graphique.Tile.SqueletonSpawnTile;
import Graphique.Tile.Tile;
import Graphique.Tile.TileBreakable;
import Graphique.Tile.TileLoad;
import org.newdawn.slick.Graphics;
import Graphique.Tile.TileSolid;
import Graphique.Tile.TriggerTile;
import Graphique.Tile.VoidTile;
import Graphique.Tile.ZombieSpawnTile;
import static Level.LevelManager.inventaire;
import States.Inventaire;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import javax.swing.SwingUtilities;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Input;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.geom.Rectangle;
import org.newdawn.slick.geom.Vector2f;
import org.newdawn.slick.gui.MouseOverArea;
import org.newdawn.slick.tiled.TiledMap;

/**
 *
 * @author wail
 */
public class Map extends LevelManager {
    
    private GameContainer gc;
    private int solidTileDown, triggerTileDown, WIDTH, HEIGHT;
    private float scale = 2;
    private static final int solidTileSetID = 0, solidTileID = 1;

    private Rectangle[] recsCollision;
    private ArrayList<Rectangle> recsTrigger;

    private TileSolid[] tabSolidTile;
    private ArrayList<Tile> listeTile, listeEntitySpawnTile;
    private TileSolid tileSolid;
    private TriggerTile tileTrigger;
    private float xOverLap, yOverLap;

    private boolean chestOpened;
    protected TiledMap tiledMap;

    public Map(GameContainer gc) throws SlickException {
        this.gc = gc;
    }
    public int taille;

    public TiledMap loadMap(String path) throws SlickException {

        //TiledMap
        this.tiledMap = new TiledMap(path);

        tileSolid = new TileSolid(tiledMap);
        tileTrigger = new TriggerTile(tiledMap);
        tileTrigger.compteurTile(tiledMap);

        taille = tileSolid.compteurTileSolid(tiledMap);

        this.tabSolidTile = new TileSolid[taille];

        listeTile = new ArrayList<>();
        listeEntitySpawnTile = new ArrayList<>();

        loadMapTile(tiledMap);
        initListeTile(tiledMap);
        initListeEntitySpawnTile(tiledMap);
        tileSolidTriggerPosition(tiledMap);
        
        addEntities(tiledMap);
        boxCollision(tiledMap);
        boxTrigger(tiledMap);

        this.WIDTH = tiledMap.getHeight();
        this.HEIGHT = tiledMap.getWidth();

        return tiledMap;
    }

    public void render(Graphics g, Map map) {

        map.tiledMap.render(0, 0);

    }

    public void renderLayer(Graphics g, Map map, int layer) {
        map.tiledMap.render(0, 0, layer);
    }

    public void initListeTile(TiledMap map) {
        listeTile.clear();
        for (int i = 0; i < map.getWidth(); i++) {
            for (int j = 0; j < map.getHeight(); j++) {

                if (map.getTileId(i, j, 2) == 2) {

                    listeTile.add(new DoorTile(map));
                }
                if (map.getTileId(i, j, 2) == 3) {
                    listeTile.add(new OpenedDoorTile(map));

                }
                if (map.getTileId(i, j, 2) == 4) {
                    listeTile.add(new ChestTile(map));
                }
                if (map.getTileId(i, j, 2) == 5) {
                    listeTile.add(new OpenedChestTile(map));
                }
                if (map.getTileId(i, j, 2) == 6) {
                    listeTile.add(new MetalDoor(map));
                }
                if (map.getTileId(i, j, 2) == 7) {
                    listeTile.add(new OpenedMetalDoor(map));
                }
                if (map.getTileId(i, j, 2) == 8) {
                    listeTile.add(new TileLoad(map));
                }
                if (map.getTileId(i, j, 2) == 21) {
                    listeTile.add(new TileBreakable(map));
                }
                if (map.getTileId(i, j, 2) == 22) {
                    listeTile.add(new VoidTile(map));
                }

            }
        }

    }
    public void initListeEntitySpawnTile(TiledMap map){
        
        for (int i = 0; i < map.getWidth(); i++) {
            for (int j = 0; j < map.getHeight(); j++) {
                
                if(map.getTileId(i, j, solidTileSetID)==9){
                    listeEntitySpawnTile.add(new BatSpawnTile(map));
                }
                if(map.getTileId(i, j, solidTileSetID)==10){
                    listeEntitySpawnTile.add(new SqueletonSpawnTile(map));
                }
                if(map.getTileId(i, j, solidTileSetID)==11){
                    listeEntitySpawnTile.add(new ZombieSpawnTile(map));
                }
                if(map.getTileId(i, j, solidTileSetID)==12){
                    listeEntitySpawnTile.add(new SpiderSpawnTile(map));
                }

            }
        }
    }
    public void addEntities(TiledMap map) throws SlickException{
        for(Tile tile : listeEntitySpawnTile){
            
             if(tile instanceof BatSpawnTile){
                  listeEntities.add(new BatEntity(tile.getx(), tile.gety()));
                  
                
                  
              }
              if(tile instanceof SqueletonSpawnTile){
                  listeEntities.add(new SqueletonEntity(tile.getx(), tile.gety()));
              }
              if(tile instanceof ZombieSpawnTile){
                  listeEntities.add(new ZombieEntity(tile.getx(), tile.gety()));
              }
              if(tile instanceof SpiderSpawnTile){
                  listeEntities.add(new SpiderEntity(tile.getx(), tile.gety()));
              }
     
        }
      
    }

    public void tileSolidTriggerPosition(TiledMap map) {

        int k = 0;
        int l = 0;
        int x = 0;
        for (int i = 0; i < map.getWidth(); i++) {
            for (int j = 0; j < map.getHeight(); j++) {
                if (map.getTileId(i, j, solidTileSetID) == solidTileID) {

                    if (k < tileSolid.solidTileDown) {
                        tabSolidTile[k].setX(i * 32);
                        tabSolidTile[k].setY(j * 32);
                    }
                    k++;
                }
                

                if (l < listeTile.size()) {

                    switch (map.getTileId(i, j, 2)) {
                        case 2:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                        case 3:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                        case 4:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                        case 5:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                        case 6:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                        case 7:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;

                        case 21:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                        case 22:

                            listeTile.get(l).setX(i * 32);
                            listeTile.get(l).setY(j * 32);
                            l++;
                            break;
                    }

                }
                if(x < listeEntitySpawnTile.size()){
                    switch (map.getTileId(i, j,  solidTileSetID)) {
                        case 9:

                            listeEntitySpawnTile.get(x).setX(i * 32);
                            listeEntitySpawnTile.get(x).setY(j * 32);
                            
                            x++;
                            break;
                        case 10:

                            listeEntitySpawnTile.get(x).setX(i * 32);
                            listeEntitySpawnTile.get(x).setY(j * 32);
                            x++;
                            break;
                        case 11:

                            listeEntitySpawnTile.get(x).setX(i * 32);
                            listeEntitySpawnTile.get(x).setY(j * 32);
                            x++;
                            break;
                        case 12:

                            listeEntitySpawnTile.get(x).setX(i * 32);
                            listeEntitySpawnTile.get(x).setY(j * 32);
                            x++;
                            break;
                    }
                }

            }
        }

    }

    public void loadMapTile(TiledMap tiledMap) {

        for (int i = 0; i < tabSolidTile.length; i++) {

            tabSolidTile[i] = new TileSolid(tiledMap);

        }
    }

    public void boxTrigger(TiledMap map) {
        recsTrigger = new ArrayList<>();
        for (int i = 0; i < listeTile.size(); i++) {

            recsTrigger.add(new Rectangle(listeTile.get(i).getx(), listeTile.get(i).gety(), listeTile.get(i).getWidth(), listeTile.get(i).getHeight()));

        }
    }

    public void boxCollision(TiledMap map) {
        recsCollision = new Rectangle[taille];
        for (int i = 0; i < taille; i++) {

            recsCollision[i] = new Rectangle(tabSolidTile[i].getx(), tabSolidTile[i].gety(), tabSolidTile[i].getWidth(), tabSolidTile[i].getHeight());

        }
    }

    public void itemPickUp(Player player, Map map) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                for (Item item : map.listeItem) {

            if (player.getTriggerRadius().intersects(item.getBox())) {
                item.setLooted(true);
                  
                inventaire.add(item);
                
                //Methode a appeler pour ne pas modifier la liste pendant qu'elle est parcourue, sinon le programme plante.
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        map.listeItem.remove(item);
                    }
                });
                
                
            }

        }
            }
        });
        
        
    }

    public boolean checkTrigger(Entity player, Map map) throws SlickException {

        boolean trigger = false;

        for (int i = 0; i < recsTrigger.size(); i++) {
            if (player.getTriggerRadius().intersects(recsTrigger.get(i))) {

                if (listeTile.get(i) instanceof DoorTile) {
                    map.tiledMap.setTileId(listeTile.get(i).getx() / 32, listeTile.get(i).gety() / 32, 2, 3);
                }
                if (listeTile.get(i) instanceof OpenedDoorTile) {

                    map.tiledMap.setTileId(listeTile.get(i).getx() / 32, listeTile.get(i).gety() / 32, 2, 2);
                }
                if (listeTile.get(i) instanceof ChestTile) {
                    Vector2f vector = new Vector2f();
                    vector.x = listeTile.get(i).getx();
                    vector.y = listeTile.get(i).gety();
                   
                    Item item = new Item(vector);
                    
                    item.setId(itemDropRate());;
                    item.getItemStats();
                  
                    listeItem.add(item);
                    
                    

                    map.tiledMap.setTileId(listeTile.get(i).getx() / 32, listeTile.get(i).gety() / 32, 2, 5);
                }

                if (listeTile.get(i) instanceof MetalDoor) {
                    map.tiledMap.setTileId(listeTile.get(i).getx() / 32, listeTile.get(i).gety() / 32, 2, 7);
                }
                if (listeTile.get(i) instanceof OpenedMetalDoor) {
                    map.tiledMap.setTileId(listeTile.get(i).getx() / 32, listeTile.get(i).gety() / 32, 2, 6);
                }
                if (listeTile.get(i) instanceof TileBreakable) {

                    map.tiledMap.setTileId(listeTile.get(i).getx() / 32, listeTile.get(i).gety() / 32, 2, 22);
                }

                initListeTile(tiledMap);
                tileSolidTriggerPosition(tiledMap);
            }
        }

        return trigger;
    }
    public int itemDropRate() {
        HashMap<Integer, Integer[]> chooseItemType = new HashMap<>();
        HashMap<Integer[], Integer[]> chooseItemRate = new HashMap<>();
        int maxProb = 5000;
        
        //double[] weaponRate = {1, 2, 7, 17, 47, 107, 167, 227, 287, 357, 427, 497, 1000};
        /*
        0.01 50  
        0.03 150
        0.05 250
        0.06 300
        0.07 350
        */
        //-------------------------------------------------------------------
                            //0.01, 0.01, 0.03,   0.05, 0.05,   0.05 , 0.06,  0.06,  0.06, 0.06,  0.07,    0.07,
        double[] weaponRate = {50,   100,  250,   500,  750,  1000,   1300,   1600,  1900, 2200, 2550, 2900, maxProb};
        int weapon[] = {      48, 55, 3, 0, 42, 4, 5, 7, 8, 24, 44, 43, 37};
        double[] offhandRate = {50, 10, 20, 30, 40, 100, 160, 220, 280, 340, 400, 460, 520, 560, 620,680,740,800,860,920,980,1040,1100};
        int offhand[] =        {1, 2, 6,   9,  10,  11, 12,  13,  14,  15,  16,  17 , 18,  19, 60, 61,   62,63,  64, 65,66, 67, 68};
        double[] bootsRate = {1, 2, 7, 17, 47, 107, 167, 227, 287, 357, 427, 497, 1000};
        int boots[] = {48, 55, 3, 0, 42, 4, 5, 7, 8, 24, 44, 43, 37};
        double[] chestRate = {1, 2, 7, 17, 47, 107, 167, 227, 287, 357, 427, 497, 1000};
        int chest[] = {48, 55, 3, 0, 42, 4, 5, 7, 8, 24, 44, 43, 37};
        double[] helmetRate = {1, 2, 7, 17, 47, 107, 167, 227, 287, 357, 427, 497, 1000};
        int helmet[] = {48, 55, 3, 0, 42, 4, 5, 7, 8, 24, 44, 43, 37};
        
        //int maxProb =  ;
     
        int dropChance = r.nextInt(maxProb);
        int i = 0;
        //0.01% chance
        while (weaponRate[i] <= dropChance) {
            i++;
        }
        return weapon[i];
    }

    public void checkTriggerCollision(Entity entity) {

        for (int i = 0; i < recsTrigger.size(); i++) {
            Rectangle A = entity.getBox();

            Rectangle B = recsTrigger.get(i);
            if (entity.getBox().intersects(recsTrigger.get(i))) {

                if (listeTile.get(i) instanceof OpenedDoorTile || listeTile.get(i) instanceof OpenedMetalDoor
                        || listeTile.get(i) instanceof VoidTile) {

                } else {
                    float inter = calculateIntersects(A.getX(), A.getX() + A.getWidth(), A.getY(), A.getY() + A.getHeight(),
                            B.getX(), B.getX() + B.getWidth(), B.getY(), B.getY() + B.getHeight());
                    if (Math.abs(yOverLap) < Math.abs(xOverLap)) {
                        if (A.getCenterY() < B.getCenterY()) {
                           entity.setY(entity.getY() - yOverLap);
                        } else {
                            entity.setY(entity.getY() + yOverLap);
                        }
                    }
                    if (Math.abs(xOverLap) < Math.abs(yOverLap)) {
                        if (A.getCenterX() < B.getCenterX()) {
                            entity.setX(entity.getX()- xOverLap);
                        } else {
                           entity.setX(entity.getX()+ xOverLap);
                        }
                    }

                }

            }
        }

    }

    public void checkCollision(Entity entity) {

        for (int i = 0; i < recsCollision.length; i++) {

            Rectangle A = entity.getBox();

            Rectangle B = recsCollision[i];

            if (entity.getBox().intersects(recsCollision[i])) {
                float inter = calculateIntersects(A.getX(), A.getX() + A.getWidth(), A.getY(), A.getY() + A.getHeight(),
                        B.getX(), B.getX() + B.getWidth(), B.getY(), B.getY() + B.getHeight());
                if (Math.abs(yOverLap) < Math.abs(xOverLap)) {
                    if (A.getCenterY() < B.getCenterY()) {
                          entity.setY(entity.getY()- yOverLap);
                    } else {
                       entity.setY(entity.getY() + yOverLap);
                    }

                }
                if (Math.abs(xOverLap) < Math.abs(yOverLap)) {
                    if (A.getCenterX() < B.getCenterX()) {
                        entity.setX(entity.getX()- xOverLap);
                        
                    } else {
                          entity.setX(entity.getX()+ xOverLap);
                        
                    }
                }
            }

        }

    }

    public boolean isInCollision(Entity entity) {
        for (int i = 0; i < recsCollision.length; i++) {
            if (entity.getBox().intersects(recsCollision[i])) {
                return true;
            }
        }
        for (int i = 0; i < recsTrigger.size(); i++) {
            if (entity.getBox().intersects(recsTrigger.get(i))) {
                if (listeTile.get(i) instanceof OpenedDoorTile) {
                    return false;
                } else {
                    return true;
                }

            }
        }
        return false;
    }

    //Debug a enlever
    public void drawCollisionRecs(Graphics g, Map map) {
//        g.draw(entity.box);
//        g.draw(entity.triggerRadius);
        for (int i = 0; i < map.recsCollision.length; i++) {

            g.draw(map.recsCollision[i]);

        }
    }

    public void drawTriggerRecs(Graphics g, Map map) {
        for (int i = 0; i < map.recsTrigger.size(); i++) {
            g.draw(map.recsTrigger.get(i));
        }
    }

    /**
     * Calcule le nombre de pixel en x et en y qui rentre dans un rectangle lors
     * d'une collision.
     *
     * @param xa1
     * @param xa2
     * @param ya1
     * @param ya2
     * @param xb1
     * @param xb2
     * @param yb1
     * @param yb2
     * @return La surface complete, en pixel, qui est rentrée en collision avec
     * un rectangle.
     */
    public float calculateIntersects(float xa1, float xa2, float ya1, float ya2, float xb1, float xb2, float yb1, float yb2) {

        xOverLap = Math.max(0, Math.min(xa2, xb2) - Math.max(xa1, xb1));
        yOverLap = Math.max(0, Math.min(ya2, yb2) - Math.max(ya1, yb1));
        float overlapArea = xOverLap * yOverLap;
        return overlapArea;

    }

    public boolean isChestOpened() {

        for (int i = 0; i < listeTile.size(); i++) {
            if (listeTile.get(i).isChestOpened()) {

                return true;
            }
        }
        return false;

    }

    public boolean isPlayerTped(Map map, Player player) {
        for (int i = 0; i < listeTile.size(); i++) {
            if (listeTile.get(i).getTile(map, player.getX(), player.getY()) == 8) {
                return true;
            }
        }
        return false;
    }
    boolean dbug;

    public void dbug(GameContainer gc, Graphics g) {

        if (gc.getInput().isKeyPressed(Input.KEY_F2)) {
            dbug = !dbug;

        }
        if (dbug) {
            drawCollisionRecs(g, this);
            drawTriggerRecs(g, this);
        }

    }

    public int getSolidTileDown() {
        return solidTileDown;
    }

    public int getHEIGHT() {
        return HEIGHT;
    }

    public int getWIDTH() {
        return WIDTH;

    }

    public TiledMap getTiledMap() {
        return tiledMap;
    }

    public static Player getPlayer() {
        return player;
    }

    public static Player2 getPlayer2() {
        return player2;
    }

    public float getScale() {
        return scale;
    }

    public void setScale(float scale) {
        this.scale = scale;
    }

    public static LinkedHashMap<Item.TypeItem, Item> getEquipedItem() {
        return equipedItem;
    }
    
    
    
    

}
